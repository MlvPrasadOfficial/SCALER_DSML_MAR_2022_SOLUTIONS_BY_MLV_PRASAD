# -*- coding: utf-8 -*-
"""PostRead-Numpy-I.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Zftm1dBMo3zYgYlW2Li2QlHe_LzwBIYj

# Supplementary Post Read for Numpy-1

In this reading, we'll cover some more useful functionality provided by Numpy

## Content

- **Datatypes**

- **Absolute values**
    - `np.absolute()`
    - `np.abs()`
 
 
- **Partitioning**
    - `np.partition()`
    - `np.argpartition()`
    
- **Resize**
    - `np.resize()`


- **Some more useful ufuncs**

- **Aggregate Functions**
    - `np.median()`


- **Trigonometric Functions**
    - `np.sin()`, `np.cos()`
    
    
- **Exponential and Logarithmic Functions**
    - `np.exp()`, `np.log()`, `np.log2()`, `np.log10()`
    
- **Condtional functions**
    - `np.where()`
    
- **Sorting**
    - `np.ndarray.sort()`
"""

import numpy as np

from matplotlib import pyplot as plt

"""## Datatypes in numpy array

You can create numpy arrays of following data types:


![image.png](attachment:image.png)
"""

arr = np.array([4 + 2j, 6 + 7j])

arr

arr.dtype

"""You can read more about it here: **https://docs.scipy.org/doc/numpy-1.10.1/user/basics.types.html**

## Arrays Filled with Sequences

### `np.logspace()`

The function `np.logspace()` is similar to `np.linspace()`, but the **increments between the elements in the array are logarithmically distributed**, and the first two arguments, for the **start** and **end** values, are the**powers of the optional base keyword argument (which defaults to 10)**. 


#### For example, to generate an array with logarithmically distributed values between 1 and 100, we can use:
"""

np.logspace(0, 2, 5) # 5 data points between 10**0=1 to 10**2=100

"""***

## Absolute values

At times, we might need to find absolute values of elements in array. Numpy provides a very easy-to-use function for this purpose

### `np.absolute()`

It calculate the absolute value element-wise. It returns an ndarray containing the absolute value of each element.
"""

x = np.array([-1.2, 1.2])
np.absolute(x)

"""If the input is a complex value, like `x = a + ib`, the absolute value is $\sqrt(a^2 + b^2)$. This is a scalar if x is a scalar."""

np.absolute(1.2 + 1j)

"""### `np.abs()`
The `abs` function can be used as a shorthand for `np.absolute` on ndarrays.
"""

x = np.array([-1.2, 1.2])
np.abs(x)

"""***

## Partitioning

We can partially sort Numpy arrays using the functions provided in the library. Let's see how:

### `np.partition()`

This method returns a partitioned copy of an array.


It creates a copy of the array with its elements rearranged in such a way that the value of the element in k-th position is in the position it would be in a sorted array. All elements smaller than the k-th element are moved before this element and all equal or greater are moved behind it. The ordering of the elements in the two partitions is undefined.


#### Let's see it in action:
"""

a = np.array([3, 4, 2, 1])
a

np.partition(a, 3)

"""3rd element in the sorted array would have been 3. So 3 is placed at the 3rd position (index 2). Rest all the elements are placed in such a manner that all elements less than partitioning element are placed before it and all elements greater than or equal to partitioning element are placed after it. The ordering of elements in the two partitions is not fixed. So, it's not sorting.


Now, if we provide with a sequence of k-th instead of a single integer value like above, it will partition all elements indexed by k-th of them into their sorted position at once. Let's see it:
"""

a = np.array([32, 50, 27, 10, 43])

np.partition(a, (1, 3))

"""1st element (index 0) in the sorted array would have been 10 and 3rd element (index 2) in the sorted array would have been 32. So, 10 and 32 are placed in the positions where they would have been in a sorted array. Rest all elements are placed such that all elements less than 10 are before it, all elements greater than 10 are after it, all elements less than 32 are before it and all elements greater than 32 are after it.

### `np.argpartition()`

It works just like `agrsort()` we saw in the lecture. It perform an indirect partition along the given axis using the algorithm specified by the kind keyword. It returns an array of indices of the same shape as the array that index data along the given axis in partitioned order.

#### Let's see its working:
"""

x = np.array([30, 40, 20, 10])
np.argpartition(x, 3)

"""This is an indirect partitioning using indices. Instead of array of elements, it gives a paritoned array of orginial indices of those elements. 


The element 30 at index 0 in original array would have been at 3rd position in sorted array. So, 0 is placed at 3rd position. Rest all original indices are arranged such that indices whose corresponding elements are less than the partitioning element are before that index 0 and indices whose corresponding elements are greater than the partitioning element are after that index 0.

***

## Resize

**It is similar to `reshape()`**
"""

a = np.arange(4)
a.resize((2,4))
a

"""### what is the difference then between resize and reshape?

The difference is that it'll add extra zeros to it if shape exceeds number of elements. However, there is a catch: it'll throw an error if array is referenced somewhere and you try resizing it
"""

b = a
a.resize((10,))

"""## Some more useful ufuncs for you

## Aggregate Functions


### `np.median()`

- `np.median()` gives **median of all values in np array**
"""

a = np.arange(12).reshape(3, 4)
a

np.median(a)

"""### we can to find the median of elements for each row or column

- **with `axis` parameter** like we did for `np.mean()` function

- **`axis = 0` ---> Changes will happen along the vertical axis**
- Median of values will be calculated **in the vertical direction**
- Rows collapse/merge when we do `axis=0`
"""

np.median(a, axis = 0)

"""Similarly, you can find the median along the horizontal axis as well using **`axis = 1`**"""

np.median(a, axis = 1 )

"""***

## Trigonometric Functions

In addition to arithmetic expressions using operators, Numpy provides functions for element-wise evaluation of many elementary trigonometric functions and operations.


Each of these functions takes a single array (of arbitrary dimension) as input and returns a new array of the same shape, where for each element the function has been applied to the corresponding element in the input array.

### `np.sin()`, `np.cos()`

This function takes only one argument and is used to compute the sine function for all values in the array:
"""

x = np.linspace(-1, 1, 11)
x

y = np.sin(np.pi * x)

np.round(y, decimals=4)

"""Here we also used the constant `np.pi` and the function `np.round()` to round the values of `y` to four decimals. 


Like the `np.sin` function, many of the elementary trigonometric math functions take one input array and produce one output array. We can also make these functions operate on two input arrays and return one array:

#### For example: $\sin^2x + \cos^2x = 1$
"""

np.add(np.sin(x) ** 2, np.cos(x) ** 2)

np.sin(x) ** 2 + np.cos(x) ** 2

"""***

## Exponential and Logarithmic Functions

### `np.exp()`

This function returns element-wise exponent raised to power of element's value
"""

x = np.arange(0,3) 
x

np.exp(x) # returns e**0, e**1, e**2

"""### `np.log()`, `np.log2()`, `np.log10()`

These functions return Logarithms of base e, 2, and 10, respectively.
"""

x = np.arange(1,11) 
x

np.log(x)

np.log10(x)

"""***

## Conditional functions

### `np.where()`

This functions returns an ndarray whose elements are chosen from x or y depending on condition.

Function signature: 
`np.where(condition, [x, y])`
"""

arr = np.arange(10)
arr

np.where(arr > 5, -1, arr)

"""When only condition is provided, it gives the index of non zero values"""

np.where(arr)

"""***

## Sorting

### `np.ndarry.sort()`

- The `np.ndarray.sort()` method **performs the sorting in place, modifying the input array**.

- It **changes the orginal array**
"""

a = np.array([2,30,41,7,17,52])
a

np.ndarray.sort(a)

a

"""***"""